{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pyadvtools","text":"<p>This package provides utility functions and classes for advanced Python programming.</p>"},{"location":"api-auto/","title":"API Reference","text":"<p>This is the complete API reference documentation for the pyadvtools library.</p>"},{"location":"api-auto/#module-list","title":"Module List","text":""},{"location":"api-auto/#root-modules","title":"Root Modules","text":"<ul> <li>core.check</li> <li>core.convert</li> <li>core.delete</li> <li>core.print</li> <li>core.sort</li> <li>core.standard</li> <li>main.auto_git</li> <li>main.dict</li> <li>main.list</li> <li>main.read_write</li> <li>tools</li> </ul>"},{"location":"api-auto/core.check/","title":"core.check","text":""},{"location":"api-auto/core.check/#pyadvtools.core.check-functions","title":"Functions","text":""},{"location":"api-auto/core.check/#pyadvtools.core.check.is_empty","title":"is_empty","text":"<pre><code>is_empty(x)\n</code></pre> <p>Check whether the input is empty.</p> Determines if the input value is considered empty based on various criteria <ul> <li>Empty strings (after stripping whitespace)</li> <li>Collections with zero length (lists, dicts, tuples)</li> <li>None values</li> <li>False boolean values</li> </ul> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Any</code> <p>The value to check for emptiness. Can be any type.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the input is considered empty, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_empty(\"\")\nTrue\n&gt;&gt;&gt; is_empty(\"   \")\nTrue\n&gt;&gt;&gt; is_empty([])\nTrue\n&gt;&gt;&gt; is_empty({})\nTrue\n&gt;&gt;&gt; is_empty(None)\nTrue\n&gt;&gt;&gt; is_empty(False)\nTrue\n&gt;&gt;&gt; is_empty(\"hello\")\nFalse\n&gt;&gt;&gt; is_empty([1, 2, 3])\nFalse\n</code></pre> Source code in <code>pyadvtools/core/check.py</code> <pre><code>def is_empty(x: Any) -&gt; bool:\n    \"\"\"Check whether the input is empty.\n\n    Determines if the input value is considered empty based on various criteria:\n        - Empty strings (after stripping whitespace)\n        - Collections with zero length (lists, dicts, tuples)\n        - None values\n        - False boolean values\n\n    Args:\n        x: The value to check for emptiness. Can be any type.\n\n    Returns:\n        bool: True if the input is considered empty, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; is_empty(\"\")\n        True\n        &gt;&gt;&gt; is_empty(\"   \")\n        True\n        &gt;&gt;&gt; is_empty([])\n        True\n        &gt;&gt;&gt; is_empty({})\n        True\n        &gt;&gt;&gt; is_empty(None)\n        True\n        &gt;&gt;&gt; is_empty(False)\n        True\n        &gt;&gt;&gt; is_empty(\"hello\")\n        False\n        &gt;&gt;&gt; is_empty([1, 2, 3])\n        False\n    \"\"\"\n    if (isinstance(x, str) and (len(x.strip()) == 0)) or (len(x) == 0) or (x is None) or (x is False):\n        return True\n    return False\n</code></pre>"},{"location":"api-auto/core.check/#pyadvtools.core.check.is_list_contain_list_contain_str","title":"is_list_contain_list_contain_str","text":"<pre><code>is_list_contain_list_contain_str(xxx)\n</code></pre> <p>Check if all nested lists contain only strings.</p> <p>Verifies that the input is a list of lists, where each inner list contains only string elements.</p> <p>Parameters:</p> Name Type Description Default <code>xxx</code> <code>list</code> <p>List of lists to check for string-only content.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all nested lists contain only strings, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_list_contain_list_contain_str([[\"a\", \"b\"], [\"c\", \"d\"]])\nTrue\n&gt;&gt;&gt; is_list_contain_list_contain_str([[\"a\", \"b\"], [\"c\", 123]])\nFalse\n&gt;&gt;&gt; is_list_contain_list_contain_str([])\nTrue\n</code></pre> Source code in <code>pyadvtools/core/check.py</code> <pre><code>def is_list_contain_list_contain_str(xxx: list) -&gt; bool:\n    \"\"\"Check if all nested lists contain only strings.\n\n    Verifies that the input is a list of lists, where each inner list\n    contains only string elements.\n\n    Args:\n        xxx: List of lists to check for string-only content.\n\n    Returns:\n        bool: True if all nested lists contain only strings, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; is_list_contain_list_contain_str([[\"a\", \"b\"], [\"c\", \"d\"]])\n        True\n        &gt;&gt;&gt; is_list_contain_list_contain_str([[\"a\", \"b\"], [\"c\", 123]])\n        False\n        &gt;&gt;&gt; is_list_contain_list_contain_str([])\n        True\n    \"\"\"\n    return all(is_list_contain_str(xx) for xx in xxx)\n</code></pre>"},{"location":"api-auto/core.check/#pyadvtools.core.check.is_list_contain_str","title":"is_list_contain_str","text":"<pre><code>is_list_contain_str(xx)\n</code></pre> <p>Check if all elements in the list are strings.</p> <p>Verifies that every element in the provided list is of string type.</p> <p>Parameters:</p> Name Type Description Default <code>xx</code> <code>list</code> <p>List of elements to check for string type.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all elements are strings, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_list_contain_str([\"hello\", \"world\", \"test\"])\nTrue\n&gt;&gt;&gt; is_list_contain_str([\"hello\", 123, \"world\"])\nFalse\n&gt;&gt;&gt; is_list_contain_str([])\nTrue\n</code></pre> Source code in <code>pyadvtools/core/check.py</code> <pre><code>def is_list_contain_str(xx: list) -&gt; bool:\n    \"\"\"Check if all elements in the list are strings.\n\n    Verifies that every element in the provided list is of string type.\n\n    Args:\n        xx: List of elements to check for string type.\n\n    Returns:\n        bool: True if all elements are strings, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; is_list_contain_str([\"hello\", \"world\", \"test\"])\n        True\n        &gt;&gt;&gt; is_list_contain_str([\"hello\", 123, \"world\"])\n        False\n        &gt;&gt;&gt; is_list_contain_str([])\n        True\n    \"\"\"\n    return all(isinstance(x, str) for x in xx)\n</code></pre>"},{"location":"api-auto/core.convert/","title":"core.convert","text":""},{"location":"api-auto/core.convert/#pyadvtools.core.convert-functions","title":"Functions","text":""},{"location":"api-auto/core.convert/#pyadvtools.core.convert.convert_str_month_to_number_month","title":"convert_str_month_to_number_month","text":"<pre><code>convert_str_month_to_number_month(month)\n</code></pre> <p>Convert month string to standardized month name.</p> <p>Takes a month string in various formats and converts it to a standardized title-case month name. Handles abbreviations, full names, and combinations.</p> <p>Parameters:</p> Name Type Description Default <code>month</code> <code>str</code> <p>Month string to convert. Can be in various formats like    \"jan\", \"January\", \"01\", \"jan-feb\", etc.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Standardized month name in title case, or original string if  conversion fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; convert_str_month_to_number_month(\"jan\")\n'January'\n&gt;&gt;&gt; convert_str_month_to_number_month(\"01\")\n'January'\n&gt;&gt;&gt; convert_str_month_to_number_month(\"jan-feb\")\n'January-February'\n&gt;&gt;&gt; convert_str_month_to_number_month(\"invalid\")\n'invalid'\n</code></pre> Source code in <code>pyadvtools/core/convert.py</code> <pre><code>def convert_str_month_to_number_month(month: str) -&gt; str:\n    \"\"\"Convert month string to standardized month name.\n\n    Takes a month string in various formats and converts it to a standardized\n    title-case month name. Handles abbreviations, full names, and combinations.\n\n    Args:\n        month: Month string to convert. Can be in various formats like\n               \"jan\", \"January\", \"01\", \"jan-feb\", etc.\n\n    Returns:\n        str: Standardized month name in title case, or original string if\n             conversion fails.\n\n    Examples:\n        &gt;&gt;&gt; convert_str_month_to_number_month(\"jan\")\n        'January'\n        &gt;&gt;&gt; convert_str_month_to_number_month(\"01\")\n        'January'\n        &gt;&gt;&gt; convert_str_month_to_number_month(\"jan-feb\")\n        'January-February'\n        &gt;&gt;&gt; convert_str_month_to_number_month(\"invalid\")\n        'invalid'\n    \"\"\"\n    months = months_dict(\"str\")\n\n    month = month.strip()\n    if month == \"\":\n        return month\n\n    new_month = month\n\n    month_ = re.sub(r\"[\u2013\\-/]+\", \"-\", month.strip().lower()).replace(\".\", \"\")\n    if month_ in months_list():\n        if months.get(month_):\n            new_month = months.get(month_, month)\n            new_month = new_month.title()\n        else:\n            new_months = [months.get(i.strip().lower(), i) for i in month_.split(\"-\")]\n            new_months = [m.title() for m in new_months]\n            new_month = \"-\".join(new_months)\n    else:\n        print(f\"Not standard month: `{month}` in `convert_str_month_to_number_month`.\")\n    return new_month\n</code></pre>"},{"location":"api-auto/core.convert/#pyadvtools.core.convert.convert_to_ordered_number","title":"convert_to_ordered_number","text":"<pre><code>convert_to_ordered_number(number)\n</code></pre> <p>Convert an integer to its ordinal form (1<sup>st</sup>, 2<sup>nd</sup>, 3<sup>rd</sup>, etc.).</p> <p>Converts a non-negative integer to its ordinal representation by adding the appropriate suffix (st, nd, rd, th) based on the number's ending.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>The integer to convert to ordinal form. Negative numbers     are returned unchanged.</p> required <p>Returns:</p> Type Description <code>str | int</code> <p>Union[str, int]: Ordinal string for non-negative numbers, original             integer for negative numbers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; convert_to_ordered_number(1)\n'1st'\n&gt;&gt;&gt; convert_to_ordered_number(2)\n'2nd'\n&gt;&gt;&gt; convert_to_ordered_number(3)\n'3rd'\n&gt;&gt;&gt; convert_to_ordered_number(4)\n'4th'\n&gt;&gt;&gt; convert_to_ordered_number(21)\n'21st'\n&gt;&gt;&gt; convert_to_ordered_number(-5)\n-5\n</code></pre> Source code in <code>pyadvtools/core/convert.py</code> <pre><code>def convert_to_ordered_number(number: int) -&gt; str | int:\n    \"\"\"Convert an integer to its ordinal form (1st, 2nd, 3rd, etc.).\n\n    Converts a non-negative integer to its ordinal representation by adding\n    the appropriate suffix (st, nd, rd, th) based on the number's ending.\n\n    Args:\n        number: The integer to convert to ordinal form. Negative numbers\n                are returned unchanged.\n\n    Returns:\n        Union[str, int]: Ordinal string for non-negative numbers, original\n                        integer for negative numbers.\n\n    Examples:\n        &gt;&gt;&gt; convert_to_ordered_number(1)\n        '1st'\n        &gt;&gt;&gt; convert_to_ordered_number(2)\n        '2nd'\n        &gt;&gt;&gt; convert_to_ordered_number(3)\n        '3rd'\n        &gt;&gt;&gt; convert_to_ordered_number(4)\n        '4th'\n        &gt;&gt;&gt; convert_to_ordered_number(21)\n        '21st'\n        &gt;&gt;&gt; convert_to_ordered_number(-5)\n        -5\n    \"\"\"\n    if number &lt; 0:\n        return number\n\n    new_number = number % 100\n    number_list_1 = (1, 21, 31, 41, 51, 61, 71, 81, 91)\n    number_list_2 = (2, 22, 32, 42, 52, 62, 72, 82, 92)\n    number_list_3 = (3, 23, 33, 43, 53, 63, 73, 83, 93)\n\n    if new_number in number_list_1:\n        return f\"{number}st\"\n    elif new_number in number_list_2:\n        return f\"{number}nd\"\n    elif new_number in number_list_3:\n        return f\"{number}rd\"\n    return f\"{number}rd\"\n</code></pre>"},{"location":"api-auto/core.convert/#pyadvtools.core.convert.months_dict","title":"months_dict","text":"<pre><code>months_dict(str_int='str')\n</code></pre> <p>Create a dictionary mapping month names to their numeric representations.</p> <p>Generates a comprehensive dictionary that maps various month name formats to their corresponding string or integer representations.</p> <p>Parameters:</p> Name Type Description Default <code>str_int</code> <code>str</code> <p>Format for the output values. \"str\" returns string numbers,     \"int\" returns integer numbers, anything else returns empty dict.</p> <code>'str'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary mapping month names (lowercase) to their numeric   representations. Keys include full names, abbreviations, and   numeric strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; months = months_dict(\"str\")\n&gt;&gt;&gt; months[\"january\"]\n'1'\n&gt;&gt;&gt; months[\"jan\"]\n'1'\n&gt;&gt;&gt; months[\"01\"]\n'1'\n</code></pre> <pre><code>&gt;&gt;&gt; months = months_dict(\"int\")\n&gt;&gt;&gt; months[\"january\"]\n1\n&gt;&gt;&gt; months[\"december\"]\n12\n</code></pre> Source code in <code>pyadvtools/core/convert.py</code> <pre><code>def months_dict(str_int: str = \"str\") -&gt; dict:\n    \"\"\"Create a dictionary mapping month names to their numeric representations.\n\n    Generates a comprehensive dictionary that maps various month name formats\n    to their corresponding string or integer representations.\n\n    Args:\n        str_int: Format for the output values. \"str\" returns string numbers,\n                \"int\" returns integer numbers, anything else returns empty dict.\n\n    Returns:\n        dict: Dictionary mapping month names (lowercase) to their numeric\n              representations. Keys include full names, abbreviations, and\n              numeric strings.\n\n    Examples:\n        &gt;&gt;&gt; months = months_dict(\"str\")\n        &gt;&gt;&gt; months[\"january\"]\n        '1'\n        &gt;&gt;&gt; months[\"jan\"]\n        '1'\n        &gt;&gt;&gt; months[\"01\"]\n        '1'\n\n        &gt;&gt;&gt; months = months_dict(\"int\")\n        &gt;&gt;&gt; months[\"january\"]\n        1\n        &gt;&gt;&gt; months[\"december\"]\n        12\n    \"\"\"\n    months = {\n        \"January\": [\"1\", 1],\n        \"February\": [\"2\", 2],\n        \"March\": [\"3\", 3],\n        \"April\": [\"4\", 4],\n        \"May\": [\"5\", 5],\n        \"June\": [\"6\", 6],\n        \"July\": [\"7\", 7],\n        \"August\": [\"8\", 8],\n        \"September\": [\"9\", 9],\n        \"October\": [\"10\", 10],\n        \"November\": [\"11\", 11],\n        \"December\": [\"12\", 12],\n        \"Jan\": [\"1\", 1],\n        \"Feb\": [\"2\", 2],\n        \"Mar\": [\"3\", 3],\n        \"Apr\": [\"4\", 4],\n        \"Jun\": [\"6\", 6],\n        \"Jul\": [\"7\", 7],\n        \"Aug\": [\"8\", 8],\n        \"Sep\": [\"9\", 9],\n        \"Sept\": [\"9\", 9],\n        \"Oct\": [\"10\", 10],\n        \"Nov\": [\"11\", 11],\n        \"Dec\": [\"12\", 12],\n        \"01\": [\"1\", 1],\n        \"02\": [\"2\", 2],\n        \"03\": [\"3\", 3],\n        \"04\": [\"4\", 4],\n        \"05\": [\"5\", 5],\n        \"06\": [\"6\", 6],\n        \"07\": [\"7\", 7],\n        \"08\": [\"8\", 8],\n        \"09\": [\"9\", 9],\n        \"1\": [\"1\", 1],\n        \"2\": [\"2\", 2],\n        \"3\": [\"3\", 3],\n        \"4\": [\"4\", 4],\n        \"5\": [\"5\", 5],\n        \"6\": [\"6\", 6],\n        \"7\": [\"7\", 7],\n        \"8\": [\"8\", 8],\n        \"9\": [\"9\", 9],\n        \"10\": [\"10\", 10],\n        \"11\": [\"11\", 11],\n        \"12\": [\"12\", 12],\n    }\n    if str_int == \"str\":\n        return {key.strip().lower(): months[key][0] for key in months}\n    elif str_int == \"int\":\n        return {key.strip().lower(): months[key][1] for key in months}\n    else:\n        return {}\n</code></pre>"},{"location":"api-auto/core.convert/#pyadvtools.core.convert.months_list","title":"months_list","text":"<pre><code>months_list()\n</code></pre> <p>Generate a comprehensive list of month representations.</p> <p>Creates a list containing various formats of month names and numbers, including individual months, combinations, and seasonal terms.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: List of month representations including: - Single digit months (1-12) - Zero-padded months (01-12) - Full month names (January-December) - Abbreviated month names (Jan-Dec) - Alternative abbreviations (Sept) - Seasonal terms (spring, summer, fall, winter, quarter) - Combinations with hyphens and slashes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; months = months_list()\n&gt;&gt;&gt; \"January\" in months\nTrue\n&gt;&gt;&gt; \"01\" in months\nTrue\n&gt;&gt;&gt; \"spring\" in months\nTrue\n&gt;&gt;&gt; \"jan-feb\" in months\nTrue\n</code></pre> Source code in <code>pyadvtools/core/convert.py</code> <pre><code>def months_list() -&gt; list[str]:\n    \"\"\"Generate a comprehensive list of month representations.\n\n    Creates a list containing various formats of month names and numbers,\n    including individual months, combinations, and seasonal terms.\n\n    Returns:\n        List[str]: List of month representations including:\n            - Single digit months (1-12)\n            - Zero-padded months (01-12)\n            - Full month names (January-December)\n            - Abbreviated month names (Jan-Dec)\n            - Alternative abbreviations (Sept)\n            - Seasonal terms (spring, summer, fall, winter, quarter)\n            - Combinations with hyphens and slashes\n\n    Examples:\n        &gt;&gt;&gt; months = months_list()\n        &gt;&gt;&gt; \"January\" in months\n        True\n        &gt;&gt;&gt; \"01\" in months\n        True\n        &gt;&gt;&gt; \"spring\" in months\n        True\n        &gt;&gt;&gt; \"jan-feb\" in months\n        True\n    \"\"\"\n    month_contents_old, month_contents_new = [], []\n\n    m1 = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"]\n    m2 = [\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\"]\n    m3 = [\n        \"january\",\n        \"february\",\n        \"march\",\n        \"april\",\n        \"may\",\n        \"june\",\n        \"july\",\n        \"august\",\n        \"september\",\n        \"october\",\n        \"november\",\n        \"december\",\n    ]\n    m4 = [\"jan\", \"feb\", \"mar\", \"apr\", \"jun\", \"jul\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\"]  # May\n    m4_1 = [\"sept\"]\n    m5 = [\"spring\", \"summer\", \"fall\", \"winter\", \"quarter\"]\n\n    for months in [m1, m2, m3, m4, m4_1]:\n        month_contents_old.extend(months)\n\n    for i in month_contents_old:\n        for j in month_contents_old:\n            if i != j:\n                month_contents_new.extend([f\"{i}-{j}\", f\"{i}/{j}\"])\n\n    month_contents = []\n\n    month_contents.extend(month_contents_old)\n    month_contents.extend(month_contents_new)\n\n    month_contents.extend(m5)\n\n    for i in m5:\n        for j in m5:\n            if i != j:\n                month_contents.extend([f\"{i}-{j}\", f\"{i}/{j}\"])\n\n    return month_contents\n</code></pre>"},{"location":"api-auto/core.delete/","title":"core.delete","text":""},{"location":"api-auto/core.delete/#pyadvtools.core.delete-functions","title":"Functions","text":""},{"location":"api-auto/core.delete/#pyadvtools.core.delete.delete_empty_lines","title":"delete_empty_lines","text":"<pre><code>delete_empty_lines(data_list)\n</code></pre> <p>Remove all empty lines from a list of strings.</p> <p>Filters out lines that are empty or contain only whitespace characters, returning a new list with only non-empty lines.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>list[str]</code> <p>List of strings to filter.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: New list containing only non-empty lines.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; delete_empty_lines([\"hello\", \"\", \"world\", \"   \", \"test\"])\n['hello', 'world', 'test']\n&gt;&gt;&gt; delete_empty_lines([])\n[]\n</code></pre> Source code in <code>pyadvtools/core/delete.py</code> <pre><code>def delete_empty_lines(data_list: list[str]) -&gt; list[str]:\n    \"\"\"Remove all empty lines from a list of strings.\n\n    Filters out lines that are empty or contain only whitespace characters,\n    returning a new list with only non-empty lines.\n\n    Args:\n        data_list: List of strings to filter.\n\n    Returns:\n        List[str]: New list containing only non-empty lines.\n\n    Examples:\n        &gt;&gt;&gt; delete_empty_lines([\"hello\", \"\", \"world\", \"   \", \"test\"])\n        ['hello', 'world', 'test']\n        &gt;&gt;&gt; delete_empty_lines([])\n        []\n    \"\"\"\n    return [line for line in data_list if line.strip()]\n</code></pre>"},{"location":"api-auto/core.delete/#pyadvtools.core.delete.delete_empty_lines_first_occur","title":"delete_empty_lines_first_occur","text":"<pre><code>delete_empty_lines_first_occur(data_list)\n</code></pre> <p>Remove empty lines from the beginning of a list.</p> <p>Removes consecutive empty lines from the start of the list until the first non-empty line is encountered.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>list[str]</code> <p>List of strings to process.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: List with leading empty lines removed, or empty list       if all lines are empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; delete_empty_lines_first_occur([\"\", \"\", \"hello\", \"world\"])\n['hello', 'world']\n&gt;&gt;&gt; delete_empty_lines_first_occur([\"\", \"\", \"\"])\n[]\n&gt;&gt;&gt; delete_empty_lines_first_occur([\"hello\", \"world\"])\n['hello', 'world']\n</code></pre> Source code in <code>pyadvtools/core/delete.py</code> <pre><code>def delete_empty_lines_first_occur(data_list: list[str]) -&gt; list[str]:\n    \"\"\"Remove empty lines from the beginning of a list.\n\n    Removes consecutive empty lines from the start of the list until the\n    first non-empty line is encountered.\n\n    Args:\n        data_list: List of strings to process.\n\n    Returns:\n        List[str]: List with leading empty lines removed, or empty list\n                  if all lines are empty.\n\n    Examples:\n        &gt;&gt;&gt; delete_empty_lines_first_occur([\"\", \"\", \"hello\", \"world\"])\n        ['hello', 'world']\n        &gt;&gt;&gt; delete_empty_lines_first_occur([\"\", \"\", \"\"])\n        []\n        &gt;&gt;&gt; delete_empty_lines_first_occur([\"hello\", \"world\"])\n        ['hello', 'world']\n    \"\"\"\n    for i in range(len(data_list)):\n        if data_list[i].strip():\n            return data_list[i:]\n    return []\n</code></pre>"},{"location":"api-auto/core.delete/#pyadvtools.core.delete.delete_empty_lines_last_occur_add_new_line","title":"delete_empty_lines_last_occur_add_new_line","text":"<pre><code>delete_empty_lines_last_occur_add_new_line(data_list)\n</code></pre> <p>Remove trailing empty lines and ensure proper newline ending.</p> <p>Removes empty lines from the end of the list and ensures the last line ends with a newline character.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>list[str]</code> <p>List of strings to process.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: List with trailing empty lines removed and proper       newline ending added to the last line.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; result = delete_empty_lines_last_occur_add_new_line([\"hello\", \"world\", \"\", \"\"])\n&gt;&gt;&gt; result\n['hello', 'world\\n']\n</code></pre> Source code in <code>pyadvtools/core/delete.py</code> <pre><code>def delete_empty_lines_last_occur_add_new_line(data_list: list[str]) -&gt; list[str]:\n    r\"\"\"Remove trailing empty lines and ensure proper newline ending.\n\n    Removes empty lines from the end of the list and ensures the last\n    line ends with a newline character.\n\n    Args:\n        data_list: List of strings to process.\n\n    Returns:\n        List[str]: List with trailing empty lines removed and proper\n                  newline ending added to the last line.\n\n    Examples:\n        &gt;&gt;&gt; result = delete_empty_lines_last_occur_add_new_line([\"hello\", \"world\", \"\", \"\"])\n        &gt;&gt;&gt; result\n        ['hello', 'world\\n']\n    \"\"\"\n    data_list = delete_empty_lines_first_occur(data_list[::-1])[::-1]\n    if data_list:\n        data_list[-1] = f\"{data_list[-1].rstrip()}\\n\"\n    return data_list\n</code></pre>"},{"location":"api-auto/core.delete/#pyadvtools.core.delete.delete_files","title":"delete_files","text":"<pre><code>delete_files(path_storage, extensions)\n</code></pre> <p>Delete files with specified extensions from a directory.</p> <p>Removes all files in the given directory that have any of the specified file extensions. The function processes each file in the directory and deletes those matching the extension criteria.</p> <p>Parameters:</p> Name Type Description Default <code>path_storage</code> <code>str</code> <p>Directory path containing files to potentially delete.</p> required <code>extensions</code> <code>list[str]</code> <p>List of file extensions to match (e.g., ['.txt', '.log']).        Extensions should include the dot prefix.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Files are deleted in place, no return value.</p> Note <p>This function permanently deletes files. Use with caution.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; delete_files(\"/tmp\", [\".txt\", \".log\"])\n# Deletes all .txt and .log files in /tmp directory\n</code></pre> Source code in <code>pyadvtools/core/delete.py</code> <pre><code>def delete_files(path_storage: str, extensions: list[str]) -&gt; None:\n    \"\"\"Delete files with specified extensions from a directory.\n\n    Removes all files in the given directory that have any of the specified\n    file extensions. The function processes each file in the directory and\n    deletes those matching the extension criteria.\n\n    Args:\n        path_storage: Directory path containing files to potentially delete.\n        extensions: List of file extensions to match (e.g., ['.txt', '.log']).\n                   Extensions should include the dot prefix.\n\n    Returns:\n        None: Files are deleted in place, no return value.\n\n    Note:\n        This function permanently deletes files. Use with caution.\n\n    Examples:\n        &gt;&gt;&gt; delete_files(\"/tmp\", [\".txt\", \".log\"])\n        # Deletes all .txt and .log files in /tmp directory\n    \"\"\"\n    exts = list(set(extensions))\n    for name in os.listdir(path_storage):\n        for ext in exts:\n            if name.endswith(ext):\n                os.remove(os.path.join(path_storage, name))\n</code></pre>"},{"location":"api-auto/core.delete/#pyadvtools.core.delete.delete_python_cache","title":"delete_python_cache","text":"<pre><code>delete_python_cache(path_root)\n</code></pre> <p>Recursively delete all pycache directories.</p> <p>Walks through the directory tree starting from the given root path and removes all pycache directories and their contents.</p> <p>Parameters:</p> Name Type Description Default <code>path_root</code> <code>str</code> <p>Root directory path to start the search from.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>pycache directories are deleted in place.</p> Note <p>This function permanently deletes directories. Use with caution.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; delete_python_cache(\"/path/to/project\")\n# Removes all __pycache__ directories under /path/to/project\n</code></pre> Source code in <code>pyadvtools/core/delete.py</code> <pre><code>def delete_python_cache(path_root: str) -&gt; None:\n    \"\"\"Recursively delete all __pycache__ directories.\n\n    Walks through the directory tree starting from the given root path\n    and removes all __pycache__ directories and their contents.\n\n    Args:\n        path_root: Root directory path to start the search from.\n\n    Returns:\n        None: __pycache__ directories are deleted in place.\n\n    Note:\n        This function permanently deletes directories. Use with caution.\n\n    Examples:\n        &gt;&gt;&gt; delete_python_cache(\"/path/to/project\")\n        # Removes all __pycache__ directories under /path/to/project\n    \"\"\"\n    for root, dirs, _ in os.walk(path_root):\n        for folder in dirs:\n            if folder == \"__pycache__\":\n                shutil.rmtree(os.path.join(root, folder))\n</code></pre>"},{"location":"api-auto/core.delete/#pyadvtools.core.delete.delete_redundant_elements","title":"delete_redundant_elements","text":"<pre><code>delete_redundant_elements(element_list)\n</code></pre> <p>Remove duplicate elements while preserving order.</p> <p>Removes duplicate elements from the list while maintaining the original order of first occurrence. Also strips whitespace from each element and filters out empty elements.</p> <p>Parameters:</p> Name Type Description Default <code>element_list</code> <code>list[str]</code> <p>List of strings to deduplicate.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: New list with duplicates removed, whitespace stripped,       and empty elements filtered out, preserving original order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; delete_redundant_elements([\"a\", \"b\", \"a\", \"c\", \" b \", \"\"])\n['a', 'b', 'c']\n&gt;&gt;&gt; delete_redundant_elements([\"x\", \"x\", \"x\"])\n['x']\n</code></pre> Source code in <code>pyadvtools/core/delete.py</code> <pre><code>def delete_redundant_elements(element_list: list[str]) -&gt; list[str]:\n    \"\"\"Remove duplicate elements while preserving order.\n\n    Removes duplicate elements from the list while maintaining the original\n    order of first occurrence. Also strips whitespace from each element\n    and filters out empty elements.\n\n    Args:\n        element_list: List of strings to deduplicate.\n\n    Returns:\n        List[str]: New list with duplicates removed, whitespace stripped,\n                  and empty elements filtered out, preserving original order.\n\n    Examples:\n        &gt;&gt;&gt; delete_redundant_elements([\"a\", \"b\", \"a\", \"c\", \" b \", \"\"])\n        ['a', 'b', 'c']\n        &gt;&gt;&gt; delete_redundant_elements([\"x\", \"x\", \"x\"])\n        ['x']\n    \"\"\"\n    new_element_list = [e.strip() for e in element_list if e.strip()]\n    return sorted(set(new_element_list), key=new_element_list.index)\n</code></pre>"},{"location":"api-auto/core.print/","title":"core.print","text":""},{"location":"api-auto/core.print/#pyadvtools.core.print-functions","title":"Functions","text":""},{"location":"api-auto/core.print/#pyadvtools.core.print.print_run_time","title":"print_run_time","text":"<pre><code>print_run_time(func)\n</code></pre> <p>Decorator to measure and print function execution time.</p> <p>A decorator that wraps a function to measure its execution time and print the result. The timing is measured in seconds and displayed with the function name.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to be decorated.</p> required <p>Returns:</p> Name Type Description <code>function</code> <code>Callable</code> <p>Wrapped function that prints execution time.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @print_run_time\n... def slow_function():\n...     time.sleep(1)\n...     return \"done\"\n&gt;&gt;&gt; result = slow_function()\nRun time for slow_function: 1.000123\n&gt;&gt;&gt; result\n'done'\n</code></pre> Source code in <code>pyadvtools/core/print.py</code> <pre><code>def print_run_time(func: Callable) -&gt; Callable:\n    \"\"\"Decorator to measure and print function execution time.\n\n    A decorator that wraps a function to measure its execution time and\n    print the result. The timing is measured in seconds and displayed\n    with the function name.\n\n    Args:\n        func: The function to be decorated.\n\n    Returns:\n        function: Wrapped function that prints execution time.\n\n    Examples:\n        &gt;&gt;&gt; @print_run_time\n        ... def slow_function():\n        ...     time.sleep(1)\n        ...     return \"done\"\n        &gt;&gt;&gt; result = slow_function()\n        Run time for slow_function: 1.000123\n        &gt;&gt;&gt; result\n        'done'\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        print(f\"Run time for {func.__name__}: {time.time() - start_time}\")\n        return result\n\n    return wrapper\n</code></pre>"},{"location":"api-auto/core.sort/","title":"core.sort","text":""},{"location":"api-auto/core.sort/#pyadvtools.core.sort-functions","title":"Functions","text":""},{"location":"api-auto/core.sort/#pyadvtools.core.sort.arg_sort_int_str","title":"arg_sort_int_str","text":"<pre><code>arg_sort_int_str(str_int, reverse=False)\n</code></pre> <p>Return indices for natural sorting of strings with embedded numbers.</p> <p>Returns the indices of strings in the order they would appear if sorted using natural ordering (numeric parts sorted numerically).</p> <p>Parameters:</p> Name Type Description Default <code>str_int</code> <code>list[str]</code> <p>List of strings to get sort indices for.</p> required <code>reverse</code> <code>bool</code> <p>If True, returns indices for descending order.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[int]</code> <p>List[int]: List of indices in natural sort order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; arg_sort_int_str([\"file1.txt\", \"file10.txt\", \"file2.txt\"])\n[0, 2, 1]\n&gt;&gt;&gt; arg_sort_int_str([\"abc9\", \"abc12\", \"abc100\"])\n[0, 1, 2]\n</code></pre> Source code in <code>pyadvtools/core/sort.py</code> <pre><code>def arg_sort_int_str(str_int: list[str], reverse: bool = False) -&gt; list[int]:\n    \"\"\"Return indices for natural sorting of strings with embedded numbers.\n\n    Returns the indices of strings in the order they would appear\n    if sorted using natural ordering (numeric parts sorted numerically).\n\n    Args:\n        str_int: List of strings to get sort indices for.\n        reverse: If True, returns indices for descending order.\n\n    Returns:\n        List[int]: List of indices in natural sort order.\n\n    Examples:\n        &gt;&gt;&gt; arg_sort_int_str([\"file1.txt\", \"file10.txt\", \"file2.txt\"])\n        [0, 2, 1]\n        &gt;&gt;&gt; arg_sort_int_str([\"abc9\", \"abc12\", \"abc100\"])\n        [0, 1, 2]\n    \"\"\"\n    new_str_int = sort_int_str(str_int, reverse=reverse)\n    idx = []\n    for i in new_str_int:\n        for j in range(len(str_int)):\n            if (j not in idx) and (i == str_int[j]):\n                idx.append(j)\n                break\n    return idx\n</code></pre>"},{"location":"api-auto/core.sort/#pyadvtools.core.sort.arg_sorted","title":"arg_sorted","text":"<pre><code>arg_sorted(elements, reverse=False)\n</code></pre> <p>Return indices that would sort the list.</p> <p>Returns the indices of elements in the order they would appear if the list were sorted, without actually sorting the original list.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>list</code> <p>List of elements to get sort indices for.</p> required <code>reverse</code> <code>bool</code> <p>If True, returns indices for descending order.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[int]</code> <p>List[int]: List of indices in sort order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; arg_sorted([3, 1, 4, 1, 5])\n[1, 3, 0, 2, 4]\n&gt;&gt;&gt; arg_sorted([3, 1, 4, 1, 5], reverse=True)\n[4, 2, 0, 1, 3]\n</code></pre> Source code in <code>pyadvtools/core/sort.py</code> <pre><code>def arg_sorted(elements: list, reverse: bool = False) -&gt; list[int]:\n    \"\"\"Return indices that would sort the list.\n\n    Returns the indices of elements in the order they would appear\n    if the list were sorted, without actually sorting the original list.\n\n    Args:\n        elements: List of elements to get sort indices for.\n        reverse: If True, returns indices for descending order.\n\n    Returns:\n        List[int]: List of indices in sort order.\n\n    Examples:\n        &gt;&gt;&gt; arg_sorted([3, 1, 4, 1, 5])\n        [1, 3, 0, 2, 4]\n        &gt;&gt;&gt; arg_sorted([3, 1, 4, 1, 5], reverse=True)\n        [4, 2, 0, 1, 3]\n    \"\"\"\n    return sorted(range(len(elements)), key=lambda k: elements[k], reverse=reverse)\n</code></pre>"},{"location":"api-auto/core.sort/#pyadvtools.core.sort.sort_int_str","title":"sort_int_str","text":"<pre><code>sort_int_str(str_int, reverse=False)\n</code></pre> <p>Sort strings with natural numeric ordering.</p> <p>Sorts a list of strings using natural ordering where embedded numbers are sorted numerically rather than lexicographically.</p> <p>Parameters:</p> Name Type Description Default <code>str_int</code> <code>list[str]</code> <p>List of strings to sort.</p> required <code>reverse</code> <code>bool</code> <p>If True, sorts in descending order.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: New list with strings sorted using natural ordering.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sort_int_str([\"file1.txt\", \"file10.txt\", \"file2.txt\"])\n['file1.txt', 'file2.txt', 'file10.txt']\n&gt;&gt;&gt; sort_int_str([\"abc9\", \"abc12\", \"abc100\"])\n['abc9', 'abc12', 'abc100']\n</code></pre> Source code in <code>pyadvtools/core/sort.py</code> <pre><code>def sort_int_str(str_int: list[str], reverse: bool = False) -&gt; list[str]:\n    \"\"\"Sort strings with natural numeric ordering.\n\n    Sorts a list of strings using natural ordering where embedded numbers\n    are sorted numerically rather than lexicographically.\n\n    Args:\n        str_int: List of strings to sort.\n        reverse: If True, sorts in descending order.\n\n    Returns:\n        List[str]: New list with strings sorted using natural ordering.\n\n    Examples:\n        &gt;&gt;&gt; sort_int_str([\"file1.txt\", \"file10.txt\", \"file2.txt\"])\n        ['file1.txt', 'file2.txt', 'file10.txt']\n        &gt;&gt;&gt; sort_int_str([\"abc9\", \"abc12\", \"abc100\"])\n        ['abc9', 'abc12', 'abc100']\n    \"\"\"\n    return sorted(str_int, key=sort_strings_with_embedded_numbers, reverse=reverse)\n</code></pre>"},{"location":"api-auto/core.sort/#pyadvtools.core.sort.sort_strings_with_embedded_numbers","title":"sort_strings_with_embedded_numbers","text":"<pre><code>sort_strings_with_embedded_numbers(s)\n</code></pre> <p>Split string into parts for natural sorting with embedded numbers.</p> <p>Splits a string into alternating text and numeric parts, converting numeric parts to integers for proper natural sorting.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>String to split into sortable parts.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: List of alternating text and integer parts.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sort_strings_with_embedded_numbers(\"abc123def456\")\n['abc', 123, 'def', 456]\n&gt;&gt;&gt; sort_strings_with_embedded_numbers(\"file10.txt\")\n['file', 10, '.txt']\n</code></pre> Source code in <code>pyadvtools/core/sort.py</code> <pre><code>def sort_strings_with_embedded_numbers(s: str) -&gt; list[str]:\n    \"\"\"Split string into parts for natural sorting with embedded numbers.\n\n    Splits a string into alternating text and numeric parts, converting\n    numeric parts to integers for proper natural sorting.\n\n    Args:\n        s: String to split into sortable parts.\n\n    Returns:\n        List[str]: List of alternating text and integer parts.\n\n    Examples:\n        &gt;&gt;&gt; sort_strings_with_embedded_numbers(\"abc123def456\")\n        ['abc', 123, 'def', 456]\n        &gt;&gt;&gt; sort_strings_with_embedded_numbers(\"file10.txt\")\n        ['file', 10, '.txt']\n    \"\"\"\n    re_digits = re.compile(r\"(\\d+)\")\n    pieces = re_digits.split(s)\n    pieces[1::2] = map(int, pieces[1::2])\n    return pieces\n</code></pre>"},{"location":"api-auto/core.standard/","title":"core.standard","text":""},{"location":"api-auto/core.standard/#pyadvtools.core.standard-functions","title":"Functions","text":""},{"location":"api-auto/core.standard/#pyadvtools.core.standard.standard_path","title":"standard_path","text":"<pre><code>standard_path(p)\n</code></pre> <p>Standardize and expand a file path.</p> <p>Normalizes a file path by expanding user home directory (~) and environment variables, and handles edge cases with trailing slashes. Cross-platform compatible for Windows, macOS, and Linux.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>str</code> <p>File path string to standardize.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Standardized and expanded file path.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; standard_path(\"~/Documents/file.txt\")\n'/home/user/Documents/file.txt'  # On Unix-like systems\n&gt;&gt;&gt; standard_path(\"$HOME/file.txt\")\n'/home/user/file.txt'  # On Unix-like systems\n&gt;&gt;&gt; standard_path(\"/path/to/dir/\")\n'/path/to/dir'\n</code></pre> Source code in <code>pyadvtools/core/standard.py</code> <pre><code>def standard_path(p: str) -&gt; str:\n    \"\"\"Standardize and expand a file path.\n\n    Normalizes a file path by expanding user home directory (~) and\n    environment variables, and handles edge cases with trailing slashes.\n    Cross-platform compatible for Windows, macOS, and Linux.\n\n    Args:\n        p: File path string to standardize.\n\n    Returns:\n        str: Standardized and expanded file path.\n\n    Examples:\n        &gt;&gt;&gt; standard_path(\"~/Documents/file.txt\")\n        '/home/user/Documents/file.txt'  # On Unix-like systems\n        &gt;&gt;&gt; standard_path(\"$HOME/file.txt\")\n        '/home/user/file.txt'  # On Unix-like systems\n        &gt;&gt;&gt; standard_path(\"/path/to/dir/\")\n        '/path/to/dir'\n    \"\"\"\n    import platform\n\n    # Strip whitespace\n    p = p.strip()\n\n    # Handle empty path\n    if not p:\n        return p\n\n    # Handle trailing slash case\n    if os.path.basename(p) == \"\":\n        p = os.path.dirname(p)\n\n    # Expand user home directory (~)\n    expanded_path = os.path.expanduser(p)\n\n    # Handle environment variables - platform specific\n    system = platform.system().lower()\n    if system == \"windows\":\n        # Windows uses %VAR% syntax\n        expanded_path = os.path.expandvars(expanded_path)\n    else:\n        # Unix-like systems use $VAR syntax\n        expanded_path = os.path.expandvars(expanded_path)\n\n    # Normalize path separators for cross-platform compatibility\n    return os.path.normpath(expanded_path)\n</code></pre>"},{"location":"api-auto/main.auto_git/","title":"main.auto_git","text":""},{"location":"api-auto/main.auto_git/#pyadvtools.main.auto_git-classes","title":"Classes","text":""},{"location":"api-auto/main.auto_git/#pyadvtools.main.auto_git.GitAutoCommitter","title":"GitAutoCommitter","text":"<pre><code>GitAutoCommitter(repo_path)\n</code></pre> <p>Committer.</p> <p>A class to automatically commit changes in a Git repository. Supports both direct Git commands and custom aliases like 'acp'.</p> <p>Initialize the auto-committer with a repository path.</p> <p>Parameters:</p> Name Type Description Default <code>repo_path</code> <code>str</code> <p>Path to the Git repository</p> required Source code in <code>pyadvtools/main/auto_git.py</code> <pre><code>def __init__(self, repo_path):\n    \"\"\"Initialize the auto-committer with a repository path.\n\n    Args:\n        repo_path (str): Path to the Git repository\n    \"\"\"\n    self.repo_path = Path(repo_path).resolve()\n    self.original_dir = Path.cwd()\n</code></pre>"},{"location":"api-auto/main.auto_git/#pyadvtools.main.auto_git.GitAutoCommitter-functions","title":"Functions","text":""},{"location":"api-auto/main.auto_git/#pyadvtools.main.auto_git.GitAutoCommitter.auto_check","title":"auto_check","text":"<pre><code>auto_check(remote='origin', branch=None)\n</code></pre> <p>Check if local repository is in sync with remote repository.</p> <p>Parameters:</p> Name Type Description Default <code>remote</code> <code>str</code> <p>Remote repository name (default: \"origin\")</p> <code>'origin'</code> <code>branch</code> <code>str</code> <p>Branch name to check. If None, uses current branch.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if local and remote are in sync, False if there are differences</p> Source code in <code>pyadvtools/main/auto_git.py</code> <pre><code>def auto_check(self, remote=\"origin\", branch=None) -&gt; bool:\n    \"\"\"Check if local repository is in sync with remote repository.\n\n    Args:\n        remote (str): Remote repository name (default: \"origin\")\n        branch (str): Branch name to check. If None, uses current branch.\n\n    Returns:\n        bool: True if local and remote are in sync, False if there are differences\n    \"\"\"\n    if not self.check_git_repo():\n        print(f\"Error: {self.repo_path} is not a Git repository\")\n        return False\n\n    try:\n        os.chdir(self.repo_path)\n\n        # Get current branch if not specified\n        if branch is None:\n            branch_result = subprocess.run(\n                [\"git\", \"branch\", \"--show-current\"], capture_output=True, text=True, check=True\n            )\n            branch = branch_result.stdout.strip()\n\n        # Fetch latest remote information\n        subprocess.run([\"git\", \"fetch\", remote], check=True, capture_output=True)\n\n        # Compare local and remote commits\n        local_ref = f\"refs/heads/{branch}\"\n        remote_ref = f\"refs/remotes/{remote}/{branch}\"\n\n        # Get commit hashes\n        local_hash = subprocess.run(\n            [\"git\", \"rev-parse\", local_ref], capture_output=True, text=True, check=True\n        ).stdout.strip()\n\n        remote_hash = subprocess.run(\n            [\"git\", \"rev-parse\", remote_ref], capture_output=True, text=True, check=True\n        ).stdout.strip()\n\n        # Return True if hashes are identical\n        return local_hash == remote_hash\n\n    except subprocess.CalledProcessError as e:\n        print(f\"Error checking repository sync: {e}\")\n        return False\n    except Exception as e:\n        print(f\"Unexpected error during sync check: {e}\")\n        return False\n    finally:\n        os.chdir(self.original_dir)\n</code></pre>"},{"location":"api-auto/main.auto_git/#pyadvtools.main.auto_git.GitAutoCommitter.auto_commit","title":"auto_commit","text":"<pre><code>auto_commit(commit_message=None)\n</code></pre> <p>Automatically commit changes using direct Git commands.</p> <p>Parameters:</p> Name Type Description Default <code>commit_message</code> <code>str</code> <p>Commit message. If None, uses auto-generated message.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if commit was successful, False otherwise</p> Source code in <code>pyadvtools/main/auto_git.py</code> <pre><code>def auto_commit(self, commit_message=None) -&gt; bool:\n    \"\"\"Automatically commit changes using direct Git commands.\n\n    Args:\n        commit_message (str, optional): Commit message. If None, uses auto-generated message.\n\n    Returns:\n        bool: True if commit was successful, False otherwise\n    \"\"\"\n    if not self.check_git_repo():\n        print(f\"Error: {self.repo_path} is not a Git repository\")\n        return False\n\n    if not self.has_changes():\n        print(\"No changes to commit\")\n        return True\n\n    # Generate default commit message if none provided\n    if not commit_message:\n        timestamp = time.strftime(\"%Y-%m-%d %H:%M:%S\")\n        commit_message = f\"Auto commit {timestamp}\"\n\n    try:\n        os.chdir(self.repo_path)\n\n        # Execute git add . to stage all changes\n        subprocess.run([\"git\", \"add\", \".\"], check=True)\n\n        # Execute git commit with the provided message\n        subprocess.run([\"git\", \"commit\", \"-m\", commit_message], check=True)\n\n        print(f\"Successfully committed: {commit_message}\")\n        return True\n\n    except subprocess.CalledProcessError as e:\n        print(f\"Git operation failed: {e}\")\n        return False\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return False\n    finally:\n        os.chdir(self.original_dir)\n</code></pre>"},{"location":"api-auto/main.auto_git/#pyadvtools.main.auto_git.GitAutoCommitter.auto_pull","title":"auto_pull","text":"<pre><code>auto_pull(remote='origin', branch=None)\n</code></pre> <p>Automatically pull the latest changes from the remote repository.</p> <p>Parameters:</p> Name Type Description Default <code>remote</code> <code>str</code> <p>Remote repository name (default: \"origin\")</p> <code>'origin'</code> <code>branch</code> <code>str</code> <p>Branch name to pull from. If None, uses current branch.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if pull was successful, False otherwise</p> Source code in <code>pyadvtools/main/auto_git.py</code> <pre><code>def auto_pull(self, remote=\"origin\", branch=None) -&gt; bool:\n    \"\"\"Automatically pull the latest changes from the remote repository.\n\n    Args:\n        remote (str): Remote repository name (default: \"origin\")\n        branch (str): Branch name to pull from. If None, uses current branch.\n\n    Returns:\n        bool: True if pull was successful, False otherwise\n    \"\"\"\n    if not self.check_git_repo():\n        print(f\"Error: {self.repo_path} is not a Git repository\")\n        return False\n\n    try:\n        os.chdir(self.repo_path)\n\n        # Get current branch if not specified\n        if branch is None:\n            branch_result = subprocess.run(\n                [\"git\", \"branch\", \"--show-current\"], capture_output=True, text=True, check=True\n            )\n            branch = branch_result.stdout.strip()\n\n        # Build pull command\n        pull_command = [\"git\", \"pull\"]\n        pull_command.extend([remote, branch])\n\n        print(f\"Pulling from {remote}/{branch}...\")\n        result = subprocess.run(pull_command, check=True, text=True)\n\n        if result.returncode == 0:\n            print(f\"Successfully pulled from {remote}/{branch}\")\n            return True\n        else:\n            print(f\"Pull completed with return code: {result.returncode}\")\n            return False\n\n    except subprocess.CalledProcessError as e:\n        print(f\"Git pull failed: {e}\")\n        if \"conflict\" in e.stderr.lower() or \"conflict\" in e.stdout.lower():\n            print(\"Merge conflicts detected! Please resolve them manually.\")\n        return False\n    except Exception as e:\n        print(f\"An error occurred during pull: {e}\")\n        return False\n    finally:\n        os.chdir(self.original_dir)\n</code></pre>"},{"location":"api-auto/main.auto_git/#pyadvtools.main.auto_git.GitAutoCommitter.auto_push","title":"auto_push","text":"<pre><code>auto_push(remote='origin', branch='main')\n</code></pre> <p>Automatically push to remote repository.</p> <p>Parameters:</p> Name Type Description Default <code>remote</code> <code>str</code> <p>Remote repository name (default: \"origin\")</p> <code>'origin'</code> <code>branch</code> <code>str</code> <p>Branch name (default: \"main\")</p> <code>'main'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if push was successful, False otherwise</p> Source code in <code>pyadvtools/main/auto_git.py</code> <pre><code>def auto_push(self, remote=\"origin\", branch=\"main\") -&gt; bool:\n    \"\"\"Automatically push to remote repository.\n\n    Args:\n        remote (str): Remote repository name (default: \"origin\")\n        branch (str): Branch name (default: \"main\")\n\n    Returns:\n        bool: True if push was successful, False otherwise\n    \"\"\"\n    if not self.check_git_repo():\n        print(f\"Error: {self.repo_path} is not a Git repository\")\n        return False\n\n    try:\n        os.chdir(self.repo_path)\n\n        # Push to remote repository\n        subprocess.run([\"git\", \"push\", remote, branch], check=True)\n\n        print(f\"Successfully pushed to {remote}/{branch}\")\n        return True\n\n    except subprocess.CalledProcessError as e:\n        print(f\"Git push failed: {e}\")\n        return False\n    except Exception as e:\n        print(f\"An error occurred during push: {e}\")\n        return False\n    finally:\n        os.chdir(self.original_dir)\n</code></pre>"},{"location":"api-auto/main.auto_git/#pyadvtools.main.auto_git.GitAutoCommitter.check_git_repo","title":"check_git_repo","text":"<pre><code>check_git_repo()\n</code></pre> <p>Check if the given path is a valid Git repository.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if it's a Git repository, False otherwise</p> Source code in <code>pyadvtools/main/auto_git.py</code> <pre><code>def check_git_repo(self) -&gt; bool:\n    \"\"\"Check if the given path is a valid Git repository.\n\n    Returns:\n        bool: True if it's a Git repository, False otherwise\n    \"\"\"\n    git_dir = self.repo_path / \".git\"\n    return git_dir.exists() and git_dir.is_dir()\n</code></pre>"},{"location":"api-auto/main.auto_git/#pyadvtools.main.auto_git.GitAutoCommitter.has_changes","title":"has_changes","text":"<pre><code>has_changes()\n</code></pre> <p>Check if there are uncommitted changes in the repository.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if there are changes, False otherwise</p> Source code in <code>pyadvtools/main/auto_git.py</code> <pre><code>def has_changes(self) -&gt; bool:\n    \"\"\"Check if there are uncommitted changes in the repository.\n\n    Returns:\n        bool: True if there are changes, False otherwise\n    \"\"\"\n    try:\n        os.chdir(self.repo_path)\n        result = subprocess.run([\"git\", \"status\", \"--porcelain\"], capture_output=True, text=True, check=True)\n        return bool(result.stdout.strip())\n    finally:\n        os.chdir(self.original_dir)\n</code></pre>"},{"location":"api-auto/main.dict/","title":"main.dict","text":""},{"location":"api-auto/main.dict/#pyadvtools.main.dict-classes","title":"Classes","text":""},{"location":"api-auto/main.dict/#pyadvtools.main.dict.IterateCombineExtendDict","title":"IterateCombineExtendDict","text":"<pre><code>IterateCombineExtendDict()\n</code></pre> <p>Combine and extend nested dictionaries with list values.</p> <p>This class processes nested dictionaries where the deepest level contains lists, and combines all lists into a single flat list.</p> <p>Initialize the dictionary combiner.</p> Source code in <code>pyadvtools/main/dict.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the dictionary combiner.\"\"\"\n    pass\n</code></pre>"},{"location":"api-auto/main.dict/#pyadvtools.main.dict.IterateCombineExtendDict-functions","title":"Functions","text":""},{"location":"api-auto/main.dict/#pyadvtools.main.dict.IterateCombineExtendDict.data_combine","title":"data_combine  <code>staticmethod</code>","text":"<pre><code>data_combine(old)\n</code></pre> <p>Combine all list values from dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>dict[str, Any]</code> <p>Dictionary with list values to combine.</p> required <p>Returns:</p> Type Description <code>list[Any]</code> <p>List[Any]: Combined list of all values.</p> Source code in <code>pyadvtools/main/dict.py</code> <pre><code>@staticmethod\ndef data_combine(old: dict[str, Any]) -&gt; list[Any]:\n    \"\"\"Combine all list values from dictionary.\n\n    Args:\n        old: Dictionary with list values to combine.\n\n    Returns:\n        List[Any]: Combined list of all values.\n    \"\"\"\n    data_list = []\n    for key in old:\n        data_list.extend(old[key])\n    return data_list\n</code></pre>"},{"location":"api-auto/main.dict/#pyadvtools.main.dict.IterateCombineExtendDict.dict_update","title":"dict_update","text":"<pre><code>dict_update(data_dict)\n</code></pre> <p>Update and combine nested dictionary lists.</p> <p>Processes a nested dictionary structure and combines all list values from the deepest level into a single flat list.</p> <p>Parameters:</p> Name Type Description Default <code>data_dict</code> <code>dict[str, Any]</code> <p>Nested dictionary with list values at deepest level.</p> required <p>Returns:</p> Type Description <code>list[Any]</code> <p>List[Any]: Combined list of all values from nested structure.</p> Source code in <code>pyadvtools/main/dict.py</code> <pre><code>def dict_update(self, data_dict: dict[str, Any]) -&gt; list[Any]:\n    \"\"\"Update and combine nested dictionary lists.\n\n    Processes a nested dictionary structure and combines all list values\n    from the deepest level into a single flat list.\n\n    Args:\n        data_dict: Nested dictionary with list values at deepest level.\n\n    Returns:\n        List[Any]: Combined list of all values from nested structure.\n    \"\"\"\n    data_dict = self.dict_update_iteration(copy.deepcopy(data_dict))\n    data_list = self.data_combine(data_dict)\n    return data_list\n</code></pre>"},{"location":"api-auto/main.dict/#pyadvtools.main.dict.IterateCombineExtendDict.dict_update_iteration","title":"dict_update_iteration","text":"<pre><code>dict_update_iteration(old)\n</code></pre> <p>Recursively process nested dictionary structure.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>dict[str, Any]</code> <p>Dictionary to process recursively.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict[str, Any]: Processed dictionary structure.</p> Source code in <code>pyadvtools/main/dict.py</code> <pre><code>def dict_update_iteration(self, old: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Recursively process nested dictionary structure.\n\n    Args:\n        old: Dictionary to process recursively.\n\n    Returns:\n        Dict[str, Any]: Processed dictionary structure.\n    \"\"\"\n    for key in old:\n        if isinstance(old[key], dict):\n            old[key] = self.dict_update(old[key])\n    return old\n</code></pre>"},{"location":"api-auto/main.dict/#pyadvtools.main.dict.IterateSortDict","title":"IterateSortDict","text":"<pre><code>IterateSortDict(reverse=False)\n</code></pre> <p>Recursively sort dictionary keys using natural string ordering.</p> <p>This class provides functionality to recursively sort dictionary keys at all levels of nesting using natural string ordering that handles embedded numbers properly.</p> <p>Attributes:</p> Name Type Description <code>reverse</code> <p>If True, sorts keys in descending order.</p> <p>Initialize the dictionary sorter.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If True, sorts keys in descending order.</p> <code>False</code> Source code in <code>pyadvtools/main/dict.py</code> <pre><code>def __init__(self, reverse: bool = False) -&gt; None:\n    \"\"\"Initialize the dictionary sorter.\n\n    Args:\n        reverse: If True, sorts keys in descending order.\n    \"\"\"\n    self.reverse = reverse\n</code></pre>"},{"location":"api-auto/main.dict/#pyadvtools.main.dict.IterateSortDict-functions","title":"Functions","text":""},{"location":"api-auto/main.dict/#pyadvtools.main.dict.IterateSortDict.dict_sort","title":"dict_sort","text":"<pre><code>dict_sort(old)\n</code></pre> <p>Sort dictionary keys using natural string ordering.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>dict</code> <p>Dictionary to sort.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary with keys sorted.</p> Source code in <code>pyadvtools/main/dict.py</code> <pre><code>def dict_sort(self, old: dict) -&gt; dict:\n    \"\"\"Sort dictionary keys using natural string ordering.\n\n    Args:\n        old: Dictionary to sort.\n\n    Returns:\n        dict: Dictionary with keys sorted.\n    \"\"\"\n    return {k: old[k] for k in sort_int_str(list(old.keys()), self.reverse)}\n</code></pre>"},{"location":"api-auto/main.dict/#pyadvtools.main.dict.IterateSortDict.dict_sort_iteration","title":"dict_sort_iteration","text":"<pre><code>dict_sort_iteration(old)\n</code></pre> <p>Recursively sort nested dictionary keys.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>dict</code> <p>Dictionary to sort recursively.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary with nested keys sorted.</p> Source code in <code>pyadvtools/main/dict.py</code> <pre><code>def dict_sort_iteration(self, old: dict) -&gt; dict:\n    \"\"\"Recursively sort nested dictionary keys.\n\n    Args:\n        old: Dictionary to sort recursively.\n\n    Returns:\n        dict: Dictionary with nested keys sorted.\n    \"\"\"\n    for key in old:\n        if isinstance(old[key], dict):\n            old[key] = self.dict_update(old[key])\n    return old\n</code></pre>"},{"location":"api-auto/main.dict/#pyadvtools.main.dict.IterateSortDict.dict_update","title":"dict_update","text":"<pre><code>dict_update(old)\n</code></pre> <p>Update and sort a dictionary recursively.</p> <p>Sorts the dictionary keys at all levels using natural string ordering.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>dict</code> <p>Dictionary to sort.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary with all keys sorted recursively.</p> Source code in <code>pyadvtools/main/dict.py</code> <pre><code>def dict_update(self, old: dict) -&gt; dict:\n    \"\"\"Update and sort a dictionary recursively.\n\n    Sorts the dictionary keys at all levels using natural string ordering.\n\n    Args:\n        old: Dictionary to sort.\n\n    Returns:\n        dict: Dictionary with all keys sorted recursively.\n    \"\"\"\n    old = self.dict_sort_iteration(old)\n    old = self.dict_sort(old)\n    return old\n</code></pre>"},{"location":"api-auto/main.dict/#pyadvtools.main.dict.IterateUpdateDict","title":"IterateUpdateDict","text":"<pre><code>IterateUpdateDict()\n</code></pre> <p>Recursively update nested dictionaries.</p> <p>This class provides functionality to recursively update nested dictionaries, merging new values into existing structures while preserving nested dictionary hierarchies.</p> <p>Initialize the dictionary updater.</p> Source code in <code>pyadvtools/main/dict.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the dictionary updater.\"\"\"\n    pass\n</code></pre>"},{"location":"api-auto/main.dict/#pyadvtools.main.dict.IterateUpdateDict-functions","title":"Functions","text":""},{"location":"api-auto/main.dict/#pyadvtools.main.dict.IterateUpdateDict.dict_add","title":"dict_add  <code>staticmethod</code>","text":"<pre><code>dict_add(old, new)\n</code></pre> <p>Add new keys to dictionary.</p> <p>Adds keys from new dictionary that don't exist in old dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>dict</code> <p>Dictionary to add keys to.</p> required <code>new</code> <code>dict</code> <p>Dictionary containing keys to add.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary with added keys.</p> Source code in <code>pyadvtools/main/dict.py</code> <pre><code>@staticmethod\ndef dict_add(old: dict, new: dict) -&gt; dict:\n    \"\"\"Add new keys to dictionary.\n\n    Adds keys from new dictionary that don't exist in old dictionary.\n\n    Args:\n        old: Dictionary to add keys to.\n        new: Dictionary containing keys to add.\n\n    Returns:\n        dict: Dictionary with added keys.\n    \"\"\"\n    for key in new:\n        if key not in old:\n            old[key] = new[key]\n    return old\n</code></pre>"},{"location":"api-auto/main.dict/#pyadvtools.main.dict.IterateUpdateDict.dict_update","title":"dict_update","text":"<pre><code>dict_update(old, new)\n</code></pre> <p>Update a dictionary with new values recursively.</p> <p>Merges new dictionary values into the old dictionary, handling nested dictionaries by recursively updating them.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>dict</code> <p>Original dictionary to update.</p> required <code>new</code> <code>dict</code> <p>Dictionary containing new values to merge.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Updated dictionary with merged values.</p> Source code in <code>pyadvtools/main/dict.py</code> <pre><code>def dict_update(self, old: dict, new: dict) -&gt; dict:\n    \"\"\"Update a dictionary with new values recursively.\n\n    Merges new dictionary values into the old dictionary, handling\n    nested dictionaries by recursively updating them.\n\n    Args:\n        old: Original dictionary to update.\n        new: Dictionary containing new values to merge.\n\n    Returns:\n        dict: Updated dictionary with merged values.\n    \"\"\"\n    old = self.dict_update_iteration(old, new)\n    old = self.dict_add(old, new)\n    return old\n</code></pre>"},{"location":"api-auto/main.dict/#pyadvtools.main.dict.IterateUpdateDict.dict_update_iteration","title":"dict_update_iteration","text":"<pre><code>dict_update_iteration(old, new)\n</code></pre> <p>Recursively update nested dictionary values.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>dict</code> <p>Original dictionary to update.</p> required <code>new</code> <code>dict</code> <p>Dictionary with new values.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary with recursively updated values.</p> Source code in <code>pyadvtools/main/dict.py</code> <pre><code>def dict_update_iteration(self, old: dict, new: dict) -&gt; dict:\n    \"\"\"Recursively update nested dictionary values.\n\n    Args:\n        old: Original dictionary to update.\n        new: Dictionary with new values.\n\n    Returns:\n        dict: Dictionary with recursively updated values.\n    \"\"\"\n    for key in old:\n        if key not in new:\n            continue\n\n        if isinstance(old[key], dict) and isinstance(new[key], dict):\n            old[key] = self.dict_update(old[key], new[key])\n        else:\n            old[key] = new[key]  # update\n\n    return old\n</code></pre>"},{"location":"api-auto/main.dict/#pyadvtools.main.dict-functions","title":"Functions","text":""},{"location":"api-auto/main.list/","title":"main.list","text":""},{"location":"api-auto/main.list/#pyadvtools.main.list-functions","title":"Functions","text":""},{"location":"api-auto/main.list/#pyadvtools.main.list.combine_content_in_list","title":"combine_content_in_list","text":"<pre><code>combine_content_in_list(\n    data_list, insert_flag=None, before_after=\"after\"\n)\n</code></pre> <p>Combine content in list with optional insertion flags.</p> <p>Combines content from a list of strings or list of string lists, optionally inserting flags between each item.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>list[str] | list[list[str]]</code> <p>List of strings or list of string lists to combine.</p> required <code>insert_flag</code> <code>list[str] | str | None</code> <p>Content to insert between items. Can be a string,         list of strings, or None for no insertion.</p> <code>None</code> <code>before_after</code> <code>str</code> <p>Position to insert flag - \"before\" or \"after\" each item.</p> <code>'after'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: Combined list with optional insertions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; combine_content_in_list([\"a\", \"b\"], \"---\")\n['a', '---', 'b', '---']\n&gt;&gt;&gt; combine_content_in_list([[\"a\", \"b\"], [\"c\", \"d\"]], \"---\")\n['a', 'b', '---', 'c', 'd', '---']\n</code></pre> Source code in <code>pyadvtools/main/list.py</code> <pre><code>def combine_content_in_list(\n    data_list: list[str] | list[list[str]],\n    insert_flag: list[str] | str | None = None,\n    before_after: str = \"after\",\n) -&gt; list[str]:\n    \"\"\"Combine content in list with optional insertion flags.\n\n    Combines content from a list of strings or list of string lists,\n    optionally inserting flags between each item.\n\n    Args:\n        data_list: List of strings or list of string lists to combine.\n        insert_flag: Content to insert between items. Can be a string,\n                    list of strings, or None for no insertion.\n        before_after: Position to insert flag - \"before\" or \"after\" each item.\n\n    Returns:\n        List[str]: Combined list with optional insertions.\n\n    Examples:\n        &gt;&gt;&gt; combine_content_in_list([\"a\", \"b\"], \"---\")\n        ['a', '---', 'b', '---']\n        &gt;&gt;&gt; combine_content_in_list([[\"a\", \"b\"], [\"c\", \"d\"]], \"---\")\n        ['a', 'b', '---', 'c', 'd', '---']\n    \"\"\"\n    if before_after not in [\"after\", \"before\"]:\n        before_after = \"after\"\n\n    if insert_flag is None:\n        insert_flag = []\n    elif isinstance(insert_flag, str):\n        insert_flag = [insert_flag]\n\n    new_list = []\n    if is_list_contain_str(data_list):\n        for line in data_list:\n            if isinstance(line, str):\n                if before_after == \"after\":\n                    new_list.append(line)\n                    new_list.extend(insert_flag)\n                else:\n                    new_list.extend(insert_flag)\n                    new_list.extend(line)\n\n    elif is_list_contain_list_contain_str(data_list):\n        for line in data_list:\n            if isinstance(line, list):\n                if before_after == \"after\":\n                    new_list.extend(line)\n                    new_list.extend(insert_flag)\n                else:\n                    new_list.extend(insert_flag)\n                    new_list.extend(line)\n    else:\n        pass\n    return new_list\n</code></pre>"},{"location":"api-auto/main.list/#pyadvtools.main.list.insert_list_in_list","title":"insert_list_in_list","text":"<pre><code>insert_list_in_list(\n    data_list,\n    insert_content_list,\n    insert_flag,\n    insert_before_after=\"after\",\n    insert_times=1,\n)\n</code></pre> <p>Insert content into a list at specified positions.</p> <p>Inserts a list of content into another list either at a specific index or at positions matching a regex pattern.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>list[str]</code> <p>List to insert content into.</p> required <code>insert_content_list</code> <code>list[str]</code> <p>Content to insert.</p> required <code>insert_flag</code> <code>int | str</code> <p>Position indicator - integer index or regex pattern.</p> required <code>insert_before_after</code> <code>str</code> <p>\"before\" or \"after\" the target position.</p> <code>'after'</code> <code>insert_times</code> <code>float</code> <p>Number of times to perform insertion (for regex).</p> <code>1</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: New list with content inserted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; insert_list_in_list([\"a\", \"b\", \"c\"], [\"X\", \"Y\"], 2)\n['a', 'b', 'X', 'Y', 'c']\n&gt;&gt;&gt; insert_list_in_list([\"a\", \"b\", \"c\"], [\"X\"], \"b\", \"before\")\n['a', 'X', 'b', 'c']\n</code></pre> Source code in <code>pyadvtools/main/list.py</code> <pre><code>def insert_list_in_list(\n    data_list: list[str],\n    insert_content_list: list[str],\n    insert_flag: int | str,\n    insert_before_after: str = \"after\",\n    insert_times: float = 1,\n) -&gt; list[str]:\n    \"\"\"Insert content into a list at specified positions.\n\n    Inserts a list of content into another list either at a specific index\n    or at positions matching a regex pattern.\n\n    Args:\n        data_list: List to insert content into.\n        insert_content_list: Content to insert.\n        insert_flag: Position indicator - integer index or regex pattern.\n        insert_before_after: \"before\" or \"after\" the target position.\n        insert_times: Number of times to perform insertion (for regex).\n\n    Returns:\n        List[str]: New list with content inserted.\n\n    Examples:\n        &gt;&gt;&gt; insert_list_in_list([\"a\", \"b\", \"c\"], [\"X\", \"Y\"], 2)\n        ['a', 'b', 'X', 'Y', 'c']\n        &gt;&gt;&gt; insert_list_in_list([\"a\", \"b\", \"c\"], [\"X\"], \"b\", \"before\")\n        ['a', 'X', 'b', 'c']\n    \"\"\"\n    new_list = []\n\n    if isinstance(insert_flag, int):\n        if insert_flag &lt; len(data_list):\n            new_list.extend(data_list[: (insert_flag - 1)])  # the insert_flag in th line\n            if insert_before_after == \"before\":\n                new_list.extend(insert_content_list)\n                new_list.append(data_list[insert_flag - 1])\n            elif insert_before_after == \"after\":\n                new_list.append(data_list[insert_flag - 1])\n                new_list.extend(insert_content_list)\n            new_list.extend(data_list[insert_flag:])\n        else:\n            new_list = data_list\n\n    elif isinstance(insert_flag, str):\n        cnt = 0\n        for line in data_list:\n            if cnt &lt; insert_times and re.search(insert_flag, line):\n                cnt += 1\n                if insert_before_after == \"before\":\n                    new_list.extend(insert_content_list)\n                    new_list.append(line)\n                elif insert_before_after == \"after\":\n                    new_list.append(line)\n                    new_list.extend(insert_content_list)\n            else:\n                new_list.append(line)\n    return new_list\n</code></pre>"},{"location":"api-auto/main.list/#pyadvtools.main.list.pairwise_combine_in_list","title":"pairwise_combine_in_list","text":"<pre><code>pairwise_combine_in_list(\n    data_list_list_one, data_list_list_two, mid_flag=\"\\n\"\n)\n</code></pre> <p>Pairwise combine two lists of lists.</p> <p>Combines corresponding lists from two list-of-lists structures. The lists must have the same length.</p> <p>Parameters:</p> Name Type Description Default <code>data_list_list_one</code> <code>list[list[str]]</code> <p>First list of lists to combine.</p> required <code>data_list_list_two</code> <code>list[list[str]]</code> <p>Second list of lists to combine.</p> required <code>mid_flag</code> <code>str | list</code> <p>Content to insert between combined lists.</p> <code>'\\n'</code> <p>Returns:</p> Type Description <code>list[list[str]]</code> <p>List[List[str]]: List of combined lists, or empty list if lengths don't match.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pairwise_combine_in_list([[\"a\"], [\"b\"]], [[\"c\"], [\"d\"]])\n[['a', 'c'], ['b', 'd']]\n</code></pre> Source code in <code>pyadvtools/main/list.py</code> <pre><code>def pairwise_combine_in_list(\n    data_list_list_one: list[list[str]], data_list_list_two: list[list[str]], mid_flag: str | list = \"\\n\"\n) -&gt; list[list[str]]:\n    \"\"\"Pairwise combine two lists of lists.\n\n    Combines corresponding lists from two list-of-lists structures.\n    The lists must have the same length.\n\n    Args:\n        data_list_list_one: First list of lists to combine.\n        data_list_list_two: Second list of lists to combine.\n        mid_flag: Content to insert between combined lists.\n\n    Returns:\n        List[List[str]]: List of combined lists, or empty list if lengths don't match.\n\n    Examples:\n        &gt;&gt;&gt; pairwise_combine_in_list([[\"a\"], [\"b\"]], [[\"c\"], [\"d\"]])\n        [['a', 'c'], ['b', 'd']]\n    \"\"\"\n    if len(data_list_list_one) == 0:\n        return data_list_list_two\n    if len(data_list_list_two) == 0:\n        return data_list_list_one\n    if len(data_list_list_one) != len(data_list_list_two):\n        print(\"The length of the two inputs should be equal.\")\n        return []\n\n    if isinstance(mid_flag, str):\n        mid_flag = [mid_flag]\n\n    new_list_list = []\n    for i, j in zip(data_list_list_one, data_list_list_two, strict=True):\n        new_list = []\n        new_list.extend(i)\n        new_list.extend(j)\n        new_list_list.append(new_list)\n    return new_list_list\n</code></pre>"},{"location":"api-auto/main.list/#pyadvtools.main.list.substitute_in_list","title":"substitute_in_list","text":"<pre><code>substitute_in_list(old_list, new_list, data_list)\n</code></pre> <p>Substitute patterns in list elements.</p> <p>Performs regex substitutions on each element of a list, replacing patterns from old_list with corresponding patterns from new_list.</p> <p>Parameters:</p> Name Type Description Default <code>old_list</code> <code>list[str]</code> <p>List of regex patterns to find.</p> required <code>new_list</code> <code>list[str]</code> <p>List of replacement patterns (must match old_list length).</p> required <code>data_list</code> <code>list[str]</code> <p>List of strings to perform substitutions on.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: List with substitutions applied, or original list if       old_list and new_list lengths don't match.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; substitute_in_list([\"old\"], [\"new\"], [\"old text\", \"another old\"])\n['new text', 'another new']\n</code></pre> Source code in <code>pyadvtools/main/list.py</code> <pre><code>def substitute_in_list(old_list: list[str], new_list: list[str], data_list: list[str]) -&gt; list[str]:\n    \"\"\"Substitute patterns in list elements.\n\n    Performs regex substitutions on each element of a list, replacing\n    patterns from old_list with corresponding patterns from new_list.\n\n    Args:\n        old_list: List of regex patterns to find.\n        new_list: List of replacement patterns (must match old_list length).\n        data_list: List of strings to perform substitutions on.\n\n    Returns:\n        List[str]: List with substitutions applied, or original list if\n                  old_list and new_list lengths don't match.\n\n    Examples:\n        &gt;&gt;&gt; substitute_in_list([\"old\"], [\"new\"], [\"old text\", \"another old\"])\n        ['new text', 'another new']\n    \"\"\"\n    if len(old_list) != len(new_list):\n        print(f\"The lengths of {old_list} and {new_list} should be equal.\")\n        return data_list\n\n    new_data_list = []\n    for line in data_list:\n        for i, j in zip(old_list, new_list, strict=True):\n            line = re.sub(i, j, line)\n        new_data_list.append(line)\n    return new_data_list\n</code></pre>"},{"location":"api-auto/main.read_write/","title":"main.read_write","text":""},{"location":"api-auto/main.read_write/#pyadvtools.main.read_write-functions","title":"Functions","text":""},{"location":"api-auto/main.read_write/#pyadvtools.main.read_write.is_valid_filename","title":"is_valid_filename","text":"<pre><code>is_valid_filename(filename)\n</code></pre> <p>Check if a filename is valid for common file systems.</p> <p>Validates a filename against common file system restrictions including illegal characters, reserved patterns, and naming conventions. Cross-platform compatible for Windows, macOS, and Linux.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_valid_filename(\"test.txt\")\nTrue\n&gt;&gt;&gt; is_valid_filename(\"test\")\nFalse\n&gt;&gt;&gt; is_valid_filename(\"file&lt;name&gt;.txt\")\nFalse\n</code></pre> Source code in <code>pyadvtools/main/read_write.py</code> <pre><code>def is_valid_filename(filename: str) -&gt; bool:\n    \"\"\"Check if a filename is valid for common file systems.\n\n    Validates a filename against common file system restrictions including\n    illegal characters, reserved patterns, and naming conventions.\n    Cross-platform compatible for Windows, macOS, and Linux.\n\n    Args:\n        filename: The filename to validate.\n\n    Returns:\n        bool: True if valid, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; is_valid_filename(\"test.txt\")\n        True\n        &gt;&gt;&gt; is_valid_filename(\"test\")\n        False\n        &gt;&gt;&gt; is_valid_filename(\"file&lt;name&gt;.txt\")\n        False\n    \"\"\"\n    # Empty filename check\n    if not filename:\n        return False\n\n    # Platform-specific illegal characters\n    system = platform.system().lower()\n    if system == \"windows\":\n        # Windows illegal characters: &lt; &gt; : \" | ? * and control characters\n        illegal_chars = '&lt;&gt;:\"|?*'\n        # Also check for control characters (ASCII 0-31)\n        if any(ord(char) &lt; 32 for char in filename):\n            return False\n    else:\n        # Unix-like systems: only / and null character\n        illegal_chars = \"/\\0\"\n\n    if any(char in filename for char in illegal_chars):\n        return False\n\n    # Check for hidden file without actual name (just '.')\n    if filename == \".\":\n        return False\n\n    # Prevent directory traversal attacks\n    if \"..\" in filename:\n        return False\n\n    # Check for leading or trailing spaces\n    if filename.strip() != filename:\n        return False\n\n    # Check for consecutive spaces\n    if \"  \" in filename:\n        return False\n\n    # Windows-specific: reserved names\n    if system == \"windows\":\n        reserved_names = {\n            \"CON\",\n            \"PRN\",\n            \"AUX\",\n            \"NUL\",\n            \"COM1\",\n            \"COM2\",\n            \"COM3\",\n            \"COM4\",\n            \"COM5\",\n            \"COM6\",\n            \"COM7\",\n            \"COM8\",\n            \"COM9\",\n            \"LPT1\",\n            \"LPT2\",\n            \"LPT3\",\n            \"LPT4\",\n            \"LPT5\",\n            \"LPT6\",\n            \"LPT7\",\n            \"LPT8\",\n            \"LPT9\",\n        }\n        name_without_ext = filename.split(\".\")[0].upper()\n        if name_without_ext in reserved_names:\n            return False\n\n    # Require file extension (at least one dot)\n    if \".\" not in filename:\n        return False\n\n    return True\n</code></pre>"},{"location":"api-auto/main.read_write/#pyadvtools.main.read_write.read_list","title":"read_list","text":"<pre><code>read_list(file_name, read_flag='r', path_storage=None)\n</code></pre> <p>Read a text file and return its content as a list of lines.</p> <p>Reads a text file and returns its content as a list of strings, with proper handling of file paths, existence checks, and content formatting. Uses Unix-style line endings (\\n) consistently across all platforms.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Name of the file to read.</p> required <code>read_flag</code> <code>str</code> <p>File open mode (default: \"r\" for read).</p> <code>'r'</code> <code>path_storage</code> <code>str | None</code> <p>Optional directory path to prepend to file_name.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: List of file lines with Unix-style line endings (\\n),       or empty list if file doesn't exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; read_list(\"test.txt\")\n['line1\\n', 'line2\\n']\n&gt;&gt;&gt; read_list(\"nonexistent.txt\")\n[]\n</code></pre> Note <p>This function enforces Unix-style line endings (\\n) regardless of the host operating system. All line endings are normalized to \\n during reading.</p> Source code in <code>pyadvtools/main/read_write.py</code> <pre><code>def read_list(file_name: str, read_flag: str = \"r\", path_storage: str | None = None) -&gt; list[str]:\n    r\"\"\"Read a text file and return its content as a list of lines.\n\n    Reads a text file and returns its content as a list of strings,\n    with proper handling of file paths, existence checks, and content\n    formatting. Uses Unix-style line endings (\\n) consistently across\n    all platforms.\n\n    Args:\n        file_name: Name of the file to read.\n        read_flag: File open mode (default: \"r\" for read).\n        path_storage: Optional directory path to prepend to file_name.\n\n    Returns:\n        List[str]: List of file lines with Unix-style line endings (\\n),\n                  or empty list if file doesn't exist.\n\n    Examples:\n        &gt;&gt;&gt; read_list(\"test.txt\")\n        ['line1\\n', 'line2\\n']\n        &gt;&gt;&gt; read_list(\"nonexistent.txt\")\n        []\n\n    Note:\n        This function enforces Unix-style line endings (\\n) regardless\n        of the host operating system. All line endings are normalized\n        to \\n during reading.\n    \"\"\"\n    # Construct full path if storage directory is provided\n    if path_storage is not None:\n        file_name = os.path.join(path_storage, file_name)\n\n    # Return empty list if file doesn't exist\n    if not os.path.isfile(file_name) or not os.path.exists(file_name):\n        return []\n\n    # Read file with UTF-8 encoding and Unix-style line ending handling\n    with open(file_name, read_flag, encoding=\"utf-8\", newline=\"\\n\") as f:\n        # Read all lines preserving line endings\n        data_list = f.readlines()\n\n    # Clean up empty lines and ensure proper formatting\n    return delete_empty_lines_last_occur_add_new_line(data_list)\n</code></pre>"},{"location":"api-auto/main.read_write/#pyadvtools.main.read_write.write_list","title":"write_list","text":"<pre><code>write_list(\n    data_list,\n    file_name,\n    write_flag=\"w\",\n    path_storage=None,\n    check=True,\n    delete_first_empty=True,\n    delete_last_empty=True,\n    compulsory=False,\n    delete_original_file=False,\n)\n</code></pre> <p>Write data to a file with comprehensive file handling.</p> <p>Writes a list of strings or bytes to a file with extensive options for file handling, validation, and content processing. Enforces Unix-style line endings (\\n) for text files across all platforms.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>list[str] | list[bytes]</code> <p>List of strings or bytes to write.</p> required <code>file_name</code> <code>str</code> <p>Target file name.</p> required <code>write_flag</code> <code>str</code> <p>File open mode ('w', 'a', 'wb', etc.).</p> <code>'w'</code> <code>path_storage</code> <code>str | None</code> <p>Optional directory path for the file.</p> <code>None</code> <code>check</code> <code>bool</code> <p>If True, checks if file exists before overwriting.</p> <code>True</code> <code>delete_first_empty</code> <code>bool</code> <p>Remove empty lines from start of data.</p> <code>True</code> <code>delete_last_empty</code> <code>bool</code> <p>Remove empty lines from end of data.</p> <code>True</code> <code>compulsory</code> <code>bool</code> <p>Write file even if data is empty.</p> <code>False</code> <code>delete_original_file</code> <code>bool</code> <p>Delete existing file if data is empty.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Writes to file or prints error messages.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; write_list([\"line1\", \"line2\"], \"output.txt\")\n# Writes lines to output.txt with Unix-style line endings\n</code></pre> Note <ul> <li>Text files are always written with Unix-style line endings (\\n)   regardless of the host operating system</li> <li>Binary files are written as-is without line ending conversion</li> <li>Empty line removal occurs before line ending normalization</li> </ul> Source code in <code>pyadvtools/main/read_write.py</code> <pre><code>def write_list(\n    data_list: list[str] | list[bytes],\n    file_name: str,\n    write_flag: str = \"w\",\n    path_storage: str | None = None,\n    check: bool = True,\n    delete_first_empty: bool = True,\n    delete_last_empty: bool = True,\n    compulsory: bool = False,\n    delete_original_file: bool = False,\n) -&gt; None:\n    r\"\"\"Write data to a file with comprehensive file handling.\n\n    Writes a list of strings or bytes to a file with extensive options\n    for file handling, validation, and content processing. Enforces\n    Unix-style line endings (\\n) for text files across all platforms.\n\n    Args:\n        data_list: List of strings or bytes to write.\n        file_name: Target file name.\n        write_flag: File open mode ('w', 'a', 'wb', etc.).\n        path_storage: Optional directory path for the file.\n        check: If True, checks if file exists before overwriting.\n        delete_first_empty: Remove empty lines from start of data.\n        delete_last_empty: Remove empty lines from end of data.\n        compulsory: Write file even if data is empty.\n        delete_original_file: Delete existing file if data is empty.\n\n    Returns:\n        None: Writes to file or prints error messages.\n\n    Examples:\n        &gt;&gt;&gt; write_list([\"line1\", \"line2\"], \"output.txt\")\n        # Writes lines to output.txt with Unix-style line endings\n\n    Note:\n        - Text files are always written with Unix-style line endings (\\n)\n          regardless of the host operating system\n        - Binary files are written as-is without line ending conversion\n        - Empty line removal occurs before line ending normalization\n    \"\"\"\n    # Validate filename\n    name = os.path.basename(file_name)\n    if not is_valid_filename(name):\n        print(f\"Invalid file name: {name}\")\n        return None\n\n    # Construct full file path\n    full_file_name = os.path.join(path_storage, file_name) if path_storage else file_name\n    full_path = os.path.dirname(full_file_name)\n\n    # Handle binary data writing\n    if all(isinstance(i, bytes) for i in data_list) and write_flag == \"wb\":\n        # Create directory if needed\n        if full_path and not os.path.exists(full_path):\n            os.makedirs(full_path)\n\n        # Filter and write binary data\n        temp_data_list = [i for i in data_list if isinstance(i, bytes)]\n        with open(full_file_name, \"wb\") as f:\n            f.writelines(temp_data_list)\n\n    # Handle text data writing\n    else:\n        # Validate all items are strings\n        if not all(isinstance(i, str) for i in data_list):\n            return None\n\n        # Process text data\n        new_data_list = [i for i in data_list if isinstance(i, str)]\n\n        # Remove empty lines from start and end\n        if delete_last_empty:\n            new_data_list = delete_empty_lines_last_occur_add_new_line(new_data_list)\n        if delete_first_empty:\n            new_data_list = delete_empty_lines_first_occur(new_data_list)\n\n        # Write file if data exists or compulsory flag is set\n        if new_data_list or compulsory:\n            # Create directory if needed\n            if full_path and not os.path.exists(full_path):\n                os.makedirs(full_path)\n\n            # Check if file exists and not in append mode\n            if not re.search(\"a\", write_flag) and check and os.path.isfile(full_file_name):\n                print(f\"{full_file_name} already exists and do nothing.\")\n            else:\n                # Write data to file with Unix-style line ending handling\n                with open(full_file_name, write_flag, encoding=\"utf-8\", newline=\"\\n\") as f:\n                    f.writelines(new_data_list)\n\n        # Delete original file if data is empty and flag is set\n        elif delete_original_file and os.path.exists(full_file_name):\n            os.remove(full_file_name)\n\n    return None\n</code></pre>"},{"location":"api-auto/tools/","title":"tools","text":""},{"location":"api-auto/tools/#pyadvtools.tools-classes","title":"Classes","text":""},{"location":"api-auto/tools/#pyadvtools.tools-functions","title":"Functions","text":""},{"location":"api-auto/tools/#pyadvtools.tools.generate_nested_dict","title":"generate_nested_dict","text":"<pre><code>generate_nested_dict(path_storage)\n</code></pre> <p>Generate a nested dictionary structure representing directory hierarchy.</p> <p>Recursively walks through a directory tree and constructs a nested dictionary that mirrors the folder structure with files organized under their respective directories.</p> <p>Parameters:</p> Name Type Description Default <code>path_storage</code> <code>str</code> <p>Root directory path to generate structure from.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Nested dictionary representing directory hierarchy with sorted file lists.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generate_nested_dict(\"/path/to/project\")\n{\n    'folder1': {\n        'subfolder1': ['file1.txt', 'file2.txt'],\n        'subfolder2': ['file3.txt']\n    },\n    'folder2': ['file4.txt']\n}\n</code></pre> Source code in <code>pyadvtools/tools.py</code> <pre><code>def generate_nested_dict(path_storage: str) -&gt; dict:\n    \"\"\"Generate a nested dictionary structure representing directory hierarchy.\n\n    Recursively walks through a directory tree and constructs a nested\n    dictionary that mirrors the folder structure with files organized\n    under their respective directories.\n\n    Args:\n        path_storage: Root directory path to generate structure from.\n\n    Returns:\n        dict: Nested dictionary representing directory hierarchy with sorted file lists.\n\n    Examples:\n        &gt;&gt;&gt; generate_nested_dict(\"/path/to/project\")\n        {\n            'folder1': {\n                'subfolder1': ['file1.txt', 'file2.txt'],\n                'subfolder2': ['file3.txt']\n            },\n            'folder2': ['file4.txt']\n        }\n    \"\"\"\n    # Initialize dictionary to store flat file structure\n    files_dict = {}\n\n    # Recursively walk through all directories and subdirectories\n    for root, _, files in os.walk(path_storage, topdown=True):\n        for file in files:\n            # Create relative path key by removing root path prefix\n            # Use os.path.normpath for cross-platform path handling\n            relative_path = os.path.normpath(os.path.join(root, file))\n            relative_to_storage = os.path.relpath(relative_path, path_storage)\n            f = \".\" + os.path.sep + relative_to_storage\n\n            # Group files by their relative directory path\n            relative_dir = os.path.relpath(root, path_storage)\n            files_dict.setdefault(relative_dir, []).append(f)\n\n    # Sort file lists alphabetically for each directory\n    files_dict = {k: sorted(v) for k, v in files_dict.items()}\n\n    # Initialize nested dictionary structure\n    nested_dict = {}\n\n    # Convert flat directory structure to nested hierarchy\n    for k, v in files_dict.items():\n        # Split path into individual directory components\n        keys = [k for k in Path(k).parts if k != os.sep]\n\n        # Skip empty paths (root directory case)\n        if not keys:\n            continue\n\n        # Create nested dictionary structure for current path\n        temp_dict = {keys[-1]: v}\n        # Build nested structure backwards (from deepest to shallowest level)\n        for j in keys[::-1][1:]:\n            temp_dict = {j: temp_dict}\n\n        # Merge the temporary nested structure into the main nested dictionary\n        nested_dict = IterateUpdateDict().dict_update(nested_dict, temp_dict)\n\n    # Recursively sort the nested dictionary structure\n    nested_dict = IterateSortDict().dict_update(nested_dict)\n    return nested_dict\n</code></pre>"},{"location":"api-auto/tools/#pyadvtools.tools.iterate_obtain_full_file_names","title":"iterate_obtain_full_file_names","text":"<pre><code>iterate_obtain_full_file_names(\n    path_storage,\n    extension,\n    reverse=True,\n    is_standard_file_name=True,\n    search_year_list=[],\n)\n</code></pre> <p>Recursively retrieve full file paths with specified extension.</p> <p>Walks through a directory tree and collects files matching the given extension, with optional filtering based on year patterns and sorting.</p> <p>Parameters:</p> Name Type Description Default <code>path_storage</code> <code>str</code> <p>Root directory path to search for files.</p> required <code>extension</code> <code>str</code> <p>Target file extension to filter (e.g., 'txt', 'csv').</p> required <code>reverse</code> <code>bool</code> <p>If True, sorts files in reverse order; otherwise natural order.</p> <code>True</code> <code>is_standard_file_name</code> <code>bool</code> <p>If True, enables year-based filtering.</p> <code>True</code> <code>search_year_list</code> <code>list[str]</code> <p>List of years to filter filenames.</p> <code>[]</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: List of full file paths matching criteria, sorted accordingly.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; files = iterate_obtain_full_file_names(\"/path\", \"txt\", True, True, [\"2023\"])\n# Returns all .txt files from 2023, sorted in reverse order\n</code></pre> Source code in <code>pyadvtools/tools.py</code> <pre><code>def iterate_obtain_full_file_names(\n    path_storage: str,\n    extension: str,\n    reverse: bool = True,\n    is_standard_file_name: bool = True,\n    search_year_list: list[str] = [],\n) -&gt; list[str]:\n    \"\"\"Recursively retrieve full file paths with specified extension.\n\n    Walks through a directory tree and collects files matching the given\n    extension, with optional filtering based on year patterns and sorting.\n\n    Args:\n        path_storage: Root directory path to search for files.\n        extension: Target file extension to filter (e.g., 'txt', 'csv').\n        reverse: If True, sorts files in reverse order; otherwise natural order.\n        is_standard_file_name: If True, enables year-based filtering.\n        search_year_list: List of years to filter filenames.\n\n    Returns:\n        List[str]: List of full file paths matching criteria, sorted accordingly.\n\n    Examples:\n        &gt;&gt;&gt; files = iterate_obtain_full_file_names(\"/path\", \"txt\", True, True, [\"2023\"])\n        # Returns all .txt files from 2023, sorted in reverse order\n    \"\"\"\n    # Return empty list if the target directory does not exist\n    if not os.path.exists(path_storage):\n        return []\n\n    # Compile regex pattern for year filtering if enabled and years are provided\n    regex = None\n    if is_standard_file_name and search_year_list:\n        # Create regex pattern matching any of the specified years, such as AAAI_2020.bib\n        regex = re.compile(f\"({'|'.join(search_year_list)})\")\n\n    file_list = []\n    # Recursively walk through all directories and subdirectories\n    for root, _, files in os.walk(path_storage, topdown=True):\n        # Filter files by the target extension (handling double dots edge case)\n        files = [f for f in files if f.endswith(f\".{extension}\".replace(\"..\", \".\"))]\n\n        # Apply year-based filtering if regex pattern is available\n        if regex:\n            files = [f for f in files if regex.search(f)]\n\n        # Convert filenames to full paths and add to result list\n        file_list.extend([os.path.join(root, f) for f in files])\n\n    # Sort files using natural numeric and string sorting\n    file_list = sort_int_str(file_list, reverse=reverse)\n    return file_list\n</code></pre>"},{"location":"api-auto/tools/#pyadvtools.tools.transform_to_data_list","title":"transform_to_data_list","text":"<pre><code>transform_to_data_list(\n    original_data,\n    extension,\n    reverse=False,\n    is_standard_file_name=True,\n    search_year_list=[],\n    insert_flag=None,\n    before_after=\"after\",\n)\n</code></pre> <p>Transform input data from various formats into a unified list of strings.</p> <p>Supports multiple input types including directories, files, raw strings, and string lists, returning a consolidated list of text lines.</p> <p>Parameters:</p> Name Type Description Default <code>original_data</code> <code>list[str] | str</code> <p>Input source - directory path, file path, multi-line           string, or list of strings.</p> required <code>extension</code> <code>str</code> <p>Target file extension to filter when processing directories.</p> required <code>reverse</code> <code>bool</code> <p>Whether to reverse the order of files when reading from directory.</p> <code>False</code> <code>is_standard_file_name</code> <code>bool</code> <p>Whether to use standardized file name processing.</p> <code>True</code> <code>search_year_list</code> <code>list[str]</code> <p>Optional list of years to filter files by.</p> <code>[]</code> <code>insert_flag</code> <code>list[str] | str | None</code> <p>Content to insert between combined data chunks.</p> <code>None</code> <code>before_after</code> <code>str</code> <p>Insert position relative to existing content.</p> <code>'after'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: Consolidated list of text lines from all processed sources.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transform_to_data_list(\"/path/to/files\", \"txt\")\n# Returns combined content from all .txt files in directory\n&gt;&gt;&gt; transform_to_data_list(\"line1\\nline2\", \"txt\")\n['line1\\n', 'line2\\n']\n</code></pre> Source code in <code>pyadvtools/tools.py</code> <pre><code>def transform_to_data_list(\n    original_data: list[str] | str,\n    extension: str,\n    reverse: bool = False,\n    is_standard_file_name: bool = True,\n    search_year_list: list[str] = [],\n    insert_flag: list[str] | str | None = None,\n    before_after: str = \"after\",\n) -&gt; list[str]:\n    r\"\"\"Transform input data from various formats into a unified list of strings.\n\n    Supports multiple input types including directories, files, raw strings,\n    and string lists, returning a consolidated list of text lines.\n\n    Args:\n        original_data: Input source - directory path, file path, multi-line\n                      string, or list of strings.\n        extension: Target file extension to filter when processing directories.\n        reverse: Whether to reverse the order of files when reading from directory.\n        is_standard_file_name: Whether to use standardized file name processing.\n        search_year_list: Optional list of years to filter files by.\n        insert_flag: Content to insert between combined data chunks.\n        before_after: Insert position relative to existing content.\n\n    Returns:\n        List[str]: Consolidated list of text lines from all processed sources.\n\n    Examples:\n        &gt;&gt;&gt; transform_to_data_list(\"/path/to/files\", \"txt\")\n        # Returns combined content from all .txt files in directory\n        &gt;&gt;&gt; transform_to_data_list(\"line1\\nline2\", \"txt\")\n        ['line1\\n', 'line2\\n']\n    \"\"\"\n    # Handle string input (directory path, file path, or multi-line string)\n    if isinstance(original_data, str):\n        # Process directory input\n        if os.path.isdir(original_data):\n            # Get all files with target extension from directory\n            files = iterate_obtain_full_file_names(\n                standard_path(original_data), extension, reverse, is_standard_file_name, search_year_list\n            )\n\n            # Read all files and combine their contents\n            data_list = combine_content_in_list([read_list(f, \"r\", None) for f in files], insert_flag, before_after)\n\n        # Process file input (with matching extension or existing file)\n        elif original_data.strip().endswith(extension) or os.path.isfile(original_data):\n            # Read all lines from the file\n            data_list = read_list(original_data, \"r\", None)\n\n        # Process multi-line string input\n        else:\n            # Split string into lines while preserving line endings\n            data_list = original_data.splitlines(keepends=True)\n\n    # Handle list input (return directly)\n    else:\n        data_list = original_data\n    return data_list\n</code></pre>"},{"location":"api-manual/","title":"API Reference","text":""},{"location":"users-guide/bug-report/","title":"Bug Report","text":""},{"location":"users-guide/installation/","title":"Installation","text":"<ul> <li>uv</li> </ul> <pre><code>uv add pyadvtools\n</code></pre> <ul> <li>pip</li> </ul> <pre><code>pip install pyadvtools\n</code></pre>"},{"location":"users-guide/pull-request/","title":"Pull Request","text":""}]}